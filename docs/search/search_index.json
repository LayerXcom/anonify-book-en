{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Anonify Anonify is a privacy-protected system that enables the blockchain to be used as a tamper-proof data-sharing infrastructure using a Trusted Execution Environment (TEE) to enable high availability and flexible execution of business logic while protecting data that is not wanted to be revealed between participants in a distributed ledger. In addition, it provides an audit function that can read the data in the distributed ledger for certain entities. Instead of recording the history of state transitions in plain text like a normal blockchain, Anonify records the state data encrypted with TEE in the blockchain, calculates the state transitions in the isolated protected area of TEE, encrypts the results and records them in the blockchain. That is, the blockchain records the history of all state transitions as ciphertext, while TEE records the latest state as plaintext. The data in the encrypted area is protected from the outside at the hardware level, so that neither the administrator who runs the TEE nor the system software such as the OS can access it. References White Paper Github","title":"Anonify"},{"location":"#anonify","text":"Anonify is a privacy-protected system that enables the blockchain to be used as a tamper-proof data-sharing infrastructure using a Trusted Execution Environment (TEE) to enable high availability and flexible execution of business logic while protecting data that is not wanted to be revealed between participants in a distributed ledger. In addition, it provides an audit function that can read the data in the distributed ledger for certain entities. Instead of recording the history of state transitions in plain text like a normal blockchain, Anonify records the state data encrypted with TEE in the blockchain, calculates the state transitions in the isolated protected area of TEE, encrypts the results and records them in the blockchain. That is, the blockchain records the history of all state transitions as ciphertext, while TEE records the latest state as plaintext. The data in the encrypted area is protected from the outside at the hardware level, so that neither the administrator who runs the TEE nor the system software such as the OS can access it.","title":"Anonify"},{"location":"#references","text":"White Paper Github","title":"References"},{"location":"Concepts/overview/","text":"Anonify is a privacy-protected system that allows the blockchain to be used as a tamper-proof data sharing infrastructure. Instead of recording state transitions in plain text like a normal blockchain, Anonify records the state data encrypted by TEE in the blockchain. Anonify calculates the state transitions in an isolated protected area of the TEE server, encrypts the results and records them in the blockchain. The data in the Enclave is protected as the hardware level from the outside, so that neither the TEE administrators themselves nor the system software, such as the operating system, can access it. TEEs participating in Anonify network share the group key used for encryption and decryption via the blockchain. This allows a TEE to retrieve the ciphertext broadcasted to the blockchain and the other TEEs decrypt it in Enclave to update the latest state. In other words, the blockchain records the history of all state transitions as a ciphertext, while TEE records the latest state as a plaintext. The state transition rules handled by Enclave are enforced by the Remote Attestation mechanism of TEE.TEEs participating in the network send the Remote Attestation signed result data (REPORT) to the blockchain and verify that it hasn't been tampered with by smart contract signature validation of the REPORT. Each TEE verifies that the hash value (MRENCLAVE) of the state transition rule executed in the Enclave included in REPORT matches the one registered at setup time. As long as MMRENCLAVE matches, all TEEs are guaranteed to execute the same state transition rule. In other words, each TEE handles the state transition itself individually, and all the participants have to validate the state transition rules in a smart contract on the blockchain. This allows us to verify the correctness of the state transition rules executed in TEE between all participants, and to record the entire history of the resulting state transitions on the blockchain in an encrypted state. The above is a diagram of the state transition in TEE and the workflow for broadcasting ciphertext to the blockchain. The State Cache can only be accessed by a client that holds specific authentication information through the Authentication layer. The State Cache keeps track of the latest state. Based on the state data and input data, it processes state transitions, encrypts them with a group key at the TreeKEM layer, and broadcasts them to the blockchain. The State Hash layer performs a hash calculation to verify state matching. The ciphertext recorded in the blockchain is read by TEE, decrypted again by TreeKEM, and then recorded in the State Cache as updated state data. Sealing provides the ability to encrypt the State Cache with an on-chip key and record it to external storage. Attestation is a feature that allows you to verify the integrity of your program when you register your TEE with the blockchain.","title":"Architecture"},{"location":"Concepts/requirements/","text":"Anonify has been designed to satisfy the following properties Auditability: while all state data on the blockchain is privately protected, authorized audit entities are able to audit the state data of a particular user. The ability to audit the history of state transitions, which is a characteristic of blockchains, while guaranteeing the confidentiality of data through encryption and other means, is called Auditability here. The audit entity possesses the key to decrypt the ciphertext recorded on the blockchain, and by using that key to decrypt, it can refer to the plaintext state data. Confidentiality: By handling state data in TEE, which is isolated and protected as the hardware level, and by recording only encrypted state data in the blockchain, Anonify ensures that the data it handles cannot be viewed by unauthorized third parties. In other words, the state data resides only in the TEE, which is isolated and protected as the hardware level, is not accessible from the outside, and is encrypted with secure cryptographic algorithms on the communication path outside the TEE and on the blockchain. A group key generation mechanism using TreeKEM is used to encrypt the data recorded on the blockchain, introducing forward secrecy and an efficient key rotation mechanism. This makes it possible to minimize the impact on other ciphertext, even if the key of a specific ciphertext is compromised. General-Purpose State Transition: State transitions are processed by a general-purpose processor in TEE, and the state transition rules for the data to be hidden can be computed flexibly and with high performance as a smart contract processing. In addition, since the computation of a particular state transition is closed and handled by a particular TEE, it is possible to handle large computational costs, which would be impractical for smart contracts on the blockchain. Blockchain Agostic: Anonify, as a system on a blockchain, can fit into any blockchain that satisfies two properties: it can run smart contracts that can write verification logic, such as signature verification in Attested Execution, which is described below, and it provides client functionality that allows writing and reading of transactions to nodes from outside. Fairness: the nodes and TEEs participating in the network are all fair as a function of the overall architecture, and as a system on Anonify there is no single point of failure in state transitions and state data recording. Security Properties As a threat model, we assume that the attacker has control over the OS and network stack of all TEEs except for at least one TEE in the Anonify network. In a controlled system, an attacker can arbitrarily intercept, reorder, and delay the messages they send and receive. For this threat model, Anonify's goal is to satisfy the following security properties: * Correct Execution: indeed, processing according to the state transition rules agreed upon by the network participants is called Correct Execution here; in Anonify, the properties of Correct Execution are guaranteed based on the Remote Attestation of TEE. As a result, the encrypted data recorded on the blockchain and the plaintext data recorded in TEE are always recorded in a corresponding manner. This is accomplished by using TEE's Remote attestation to verify the identity of the executable program on the blockchain, and by matching the state in the Enclave on a block (a set of transactions). In other words, attestation ensures that all TEE's enclave executable programs participating in the network are identical and cannot be executed by unauthorized programs. * Data Availability: The nature of a legitimate client being able to access state data at any time is referred to here as Data Availability. Since the historical data of all state transitions is encrypted and recorded in the blockchain, the data is always accessible if the Data Availability of the blockchain itself is guaranteed and if you have the key to decrypt it; the TEE execution environment does not contribute to the Data Availability and it is possible to recover all state data from the blockchain records even if all the data in the TEE is lost. In other words, even if a particular participating node leaves for some reason, the system as a whole will continue to run and the data will be available unchanged. * Accountability\uff1a When an entity participating in the network performs some abnormal operation, the property that can detect which TEE performed the operation is called Accountability here. In Anonify, Accountability is guaranteed because all validations such as fraudulent signatures and REPORT submissions are done on the blockchain and the signatures are shared between all participants to see which TEE performed the operation.","title":"Properties"},{"location":"Concepts/requirements/#security-properties","text":"As a threat model, we assume that the attacker has control over the OS and network stack of all TEEs except for at least one TEE in the Anonify network. In a controlled system, an attacker can arbitrarily intercept, reorder, and delay the messages they send and receive. For this threat model, Anonify's goal is to satisfy the following security properties: * Correct Execution: indeed, processing according to the state transition rules agreed upon by the network participants is called Correct Execution here; in Anonify, the properties of Correct Execution are guaranteed based on the Remote Attestation of TEE. As a result, the encrypted data recorded on the blockchain and the plaintext data recorded in TEE are always recorded in a corresponding manner. This is accomplished by using TEE's Remote attestation to verify the identity of the executable program on the blockchain, and by matching the state in the Enclave on a block (a set of transactions). In other words, attestation ensures that all TEE's enclave executable programs participating in the network are identical and cannot be executed by unauthorized programs. * Data Availability: The nature of a legitimate client being able to access state data at any time is referred to here as Data Availability. Since the historical data of all state transitions is encrypted and recorded in the blockchain, the data is always accessible if the Data Availability of the blockchain itself is guaranteed and if you have the key to decrypt it; the TEE execution environment does not contribute to the Data Availability and it is possible to recover all state data from the blockchain records even if all the data in the TEE is lost. In other words, even if a particular participating node leaves for some reason, the system as a whole will continue to run and the data will be available unchanged. * Accountability\uff1a When an entity participating in the network performs some abnormal operation, the property that can detect which TEE performed the operation is called Accountability here. In Anonify, Accountability is guaranteed because all validations such as fraudulent signatures and REPORT submissions are done on the blockchain and the signatures are shared between all participants to see which TEE performed the operation.","title":"Security Properties"},{"location":"Concepts/technologies/","text":"We explain the key technical elements that make up Anonify. Blockchain Blockchain technology enables nodes participating in the network to verify the correctness of state transitions with each other and record and share cryptographically unfalsifiable state data. Anonify uses blockchain as a platform for processing the verification of the integrity of state transitions performed in TEE, and for sharing the history of encrypted state transitions among multiple entities. The history of encrypted state transitions is replicated between nodes, so that a TEE that holds a decryption key can always access the latest state which is agreed. TEE (Trusted Execution Environment) TEE (Trusted Execution Environment) is an extension of the processor that ensures that certain applications are run in an Enclave that is isolated from other software. The basic security requirements and interface definitions for TEE are provided by the standards institution [GlobalPlatform] (https://globalplatform.org/). TEE uses a hardware-level design to ensure that the kernel OS, hypervisor, and other authoritative system software cannot gain unauthorized access to the memory in the protected area. This means that your application is also protected against malware from system software. These security features allow general-purpose programs to be executed securely in a much more isolated environment than in the past, which has led to a growing number of applications that involve highly sensitive data. Typical example of TEE are Intel SGX, ARM TrustZone and RISC-V Keystone, and also AWS Nitro Enclaves are of a similar property. In addition to memory isolation protection, there is also a TEE with a feature called Attestation, which ensures that the intended executable binary is running on a legitimate processor. In summary, TEE has the property of providing the integrity and confidentiality of the executable binary. Also, TPM (Trusted Platform Module) is a typical standard for processor-level isolated execution; TPM differs greatly in that programs are hard-coded into the chipset, while TEE opens up the implementation of isolated execution programs to general developers. Google Titan, Apple T2, and Microsoft Pluton also have similar features, but implementations and updates are limited to product vendors only. Intel SGX Intel SGX (Software Guard Execution) is a security feature in processors on the sixth generation Intel Skylake microarchitecture and later. At processor startup, the SGX allocates a fixed size protection area as a subset of DRAM and allocates virtual memory as an enclave area. The protected area is controlled by the processor and cannot be accessed by the system software or even via DMA. In addition, the memory in the Enclave is encrypted and recorded for side-channel attack resistance, and then decrypted again during processing by the processor. In addition, the software in Enclave can only execute instructions with Ring3 (user-land) privileges in Ring protection, and cannot run applications with strong privileges such as Ring0. EENTER and EEXIT, which are specific instructions for accessing inside and outside of Enclave, are also Ring3 instructions. SGX features sealing and attestation, which can derive on-chip keys and program-dependent keys in Enclave, and encrypt them in Enclave. The ciphertext can then be exported externally and stored on a disk. If you want to restore it, you can import the ciphertext into Enclave in the same way and decrypt it by Unsealing with the same key. Another functional property, Attestation, will be discussed below. Attestation Intel SGX confidentiality is provided by Enclave's isolation protection, but this alone does not allow a third party to verify the integrity of the processor or the programs running within Enclave. The Remote Attestation feature provides an integrity. In other words, the Remote Attestation Service ensures that the correct executable is working within a particular Enclave. In contrast, Local Attestation is a protocol feature that allows Enclaves on the same machine to verify with each other that they are indeed running on the same machine, but here we discuss a particularly important Remote Attestation feature in Anonify. Remote Attestation can send a data structure called QUOTE containing the security status of a particular SGX processor and the Enclave executable binary to the Attestation Service outside the machine to obtain the resulting data called REPORT signed by the private key held by the Attestation Service, which can use Intel's IAS (Intel Attestation Service) or third party DCAP (Data Center Attestation Primitives). This REPORT contains a hash value (MRENCLAVE) that depends on the executable binary and execution environment in Enclave, and you can get the same MRENCLAVE by building the same source code with the same configuration. TreeKEM TreeKEM is a Key Encapsulation Mechanism (KEM) to efficiently generate and share group keys among members based on the binary tree structure, and KEM is a mechanism to encrypt common keys using cryptographic primitives such as HPKE (Hybrid Public Key Encryption). TreeKEM is the core technology of the Ends-to-Ends Encryption (E2EE) protocol for group messaging, known as MLS (Messaging Layer Security), and is being standardized as a draft of the IETF Working Group. If the key to a particular encrypted message is compromised in a flow where members exchange a series of encrypted messages, Forward Secrecy ensures that the ciphertext before the message is unbreakable, and Post-Compromise Security ensures that the subsequent ciphertext is unbreakable. This means that when communicating between members, a key to a particular ciphertext is compromised to ensure that other ciphertexts are not compromised in a security way. The central technical element in this MLS is TreeKEM, a group key determining mechanism for tree structures. Anonify uses TreeKEM to efficiently share the common group key used by all TEEs without leaking it to the outside world. This allows members to join, leave, and rotate their keys to the group more efficiently than with traditional methods. The result of the state transition encrypted based on this group key is then recorded in the blockchain.","title":"Technologies"},{"location":"Concepts/technologies/#blockchain","text":"Blockchain technology enables nodes participating in the network to verify the correctness of state transitions with each other and record and share cryptographically unfalsifiable state data. Anonify uses blockchain as a platform for processing the verification of the integrity of state transitions performed in TEE, and for sharing the history of encrypted state transitions among multiple entities. The history of encrypted state transitions is replicated between nodes, so that a TEE that holds a decryption key can always access the latest state which is agreed.","title":"Blockchain"},{"location":"Concepts/technologies/#tee-trusted-execution-environment","text":"TEE (Trusted Execution Environment) is an extension of the processor that ensures that certain applications are run in an Enclave that is isolated from other software. The basic security requirements and interface definitions for TEE are provided by the standards institution [GlobalPlatform] (https://globalplatform.org/). TEE uses a hardware-level design to ensure that the kernel OS, hypervisor, and other authoritative system software cannot gain unauthorized access to the memory in the protected area. This means that your application is also protected against malware from system software. These security features allow general-purpose programs to be executed securely in a much more isolated environment than in the past, which has led to a growing number of applications that involve highly sensitive data. Typical example of TEE are Intel SGX, ARM TrustZone and RISC-V Keystone, and also AWS Nitro Enclaves are of a similar property. In addition to memory isolation protection, there is also a TEE with a feature called Attestation, which ensures that the intended executable binary is running on a legitimate processor. In summary, TEE has the property of providing the integrity and confidentiality of the executable binary. Also, TPM (Trusted Platform Module) is a typical standard for processor-level isolated execution; TPM differs greatly in that programs are hard-coded into the chipset, while TEE opens up the implementation of isolated execution programs to general developers. Google Titan, Apple T2, and Microsoft Pluton also have similar features, but implementations and updates are limited to product vendors only.","title":"TEE (Trusted Execution Environment)"},{"location":"Concepts/technologies/#intel-sgx","text":"Intel SGX (Software Guard Execution) is a security feature in processors on the sixth generation Intel Skylake microarchitecture and later. At processor startup, the SGX allocates a fixed size protection area as a subset of DRAM and allocates virtual memory as an enclave area. The protected area is controlled by the processor and cannot be accessed by the system software or even via DMA. In addition, the memory in the Enclave is encrypted and recorded for side-channel attack resistance, and then decrypted again during processing by the processor. In addition, the software in Enclave can only execute instructions with Ring3 (user-land) privileges in Ring protection, and cannot run applications with strong privileges such as Ring0. EENTER and EEXIT, which are specific instructions for accessing inside and outside of Enclave, are also Ring3 instructions. SGX features sealing and attestation, which can derive on-chip keys and program-dependent keys in Enclave, and encrypt them in Enclave. The ciphertext can then be exported externally and stored on a disk. If you want to restore it, you can import the ciphertext into Enclave in the same way and decrypt it by Unsealing with the same key. Another functional property, Attestation, will be discussed below.","title":"Intel SGX"},{"location":"Concepts/technologies/#attestation","text":"Intel SGX confidentiality is provided by Enclave's isolation protection, but this alone does not allow a third party to verify the integrity of the processor or the programs running within Enclave. The Remote Attestation feature provides an integrity. In other words, the Remote Attestation Service ensures that the correct executable is working within a particular Enclave. In contrast, Local Attestation is a protocol feature that allows Enclaves on the same machine to verify with each other that they are indeed running on the same machine, but here we discuss a particularly important Remote Attestation feature in Anonify. Remote Attestation can send a data structure called QUOTE containing the security status of a particular SGX processor and the Enclave executable binary to the Attestation Service outside the machine to obtain the resulting data called REPORT signed by the private key held by the Attestation Service, which can use Intel's IAS (Intel Attestation Service) or third party DCAP (Data Center Attestation Primitives). This REPORT contains a hash value (MRENCLAVE) that depends on the executable binary and execution environment in Enclave, and you can get the same MRENCLAVE by building the same source code with the same configuration.","title":"Attestation"},{"location":"Concepts/technologies/#treekem","text":"TreeKEM is a Key Encapsulation Mechanism (KEM) to efficiently generate and share group keys among members based on the binary tree structure, and KEM is a mechanism to encrypt common keys using cryptographic primitives such as HPKE (Hybrid Public Key Encryption). TreeKEM is the core technology of the Ends-to-Ends Encryption (E2EE) protocol for group messaging, known as MLS (Messaging Layer Security), and is being standardized as a draft of the IETF Working Group. If the key to a particular encrypted message is compromised in a flow where members exchange a series of encrypted messages, Forward Secrecy ensures that the ciphertext before the message is unbreakable, and Post-Compromise Security ensures that the subsequent ciphertext is unbreakable. This means that when communicating between members, a key to a particular ciphertext is compromised to ensure that other ciphertexts are not compromised in a security way. The central technical element in this MLS is TreeKEM, a group key determining mechanism for tree structures. Anonify uses TreeKEM to efficiently share the common group key used by all TEEs without leaking it to the outside world. This allows members to join, leave, and rotate their keys to the group more efficiently than with traditional methods. The result of the state transition encrypted based on this group key is then recorded in the blockchain.","title":"TreeKEM"},{"location":"Concepts/workflow/","text":"We explain the workflow of the registration phase where TEE participates in the Anonify network, the state transition phase where transactions are sent from outside to Anonify, and the key rotation phase where the group keys used for encryption are rotated. Here, we assume that the entity sending the transaction from outside has authentication information, such as a key that can access the Enclave. Registration Phase This is the phase where the public key is registered in the blockchain after verifying that TEE is executing a legitimate state transition program. On-chain validation of REPORT obtained by Remote Attestation and registration of the Enclave Identity public key included in it to the on-chain. REPORT verification includes REPORTS signature verification and MRENCLAVE match verification. The registration phase is the phase that takes place when a specific state transition logic is determined and a new Anonify network is generated, when a TEE joins an existing Anonify network, or when the REPORT timestamp expires. The workflow from the time TEE generates an Enclave to joining a specific group on Anonify is followings: Generate a closed Identity key pair for Enclave at the time of Enclave generation. Perform Remote Attestation. Include the Identity public key and Nonce in QUOTE, send it to the Attestation Service and receive the response of REPORT with a signature. Generate a handshake to share a group key Generate a transaction containing REPORT and handshake and broadcast it to the blockchain Through a series of REPORT verification on the blockchain, the registration of TEE is completed by recording the Identity public key on the blockchain. In the verification of the REPORT, if a new Anonify network is created, the MRENCLAVE is recorded in the blockchain. On the other hand, in case of joining the existing Anonify network, check whether the MRENCLAVE already recorded in the blockchain matches the MRENCLAVE presented. State transition phase This is the phase where transactions are broadcast on the blockchain network to share the results of the cryptographic state transitions. A workflow where an external entity with credentials sends a transaction on Anonify, which is shared by the blockchain and reflected in the state of other TEEs is as follows: An external entity sends the authentication information and state transition inputs required for access to the TEE The authentication information is validated in Enclave, and the data is input to a defined state transition function and calculated TEE encrypts the result, calculates the lock parameters, signs it with the Enclave Identity private key, and broadcasts the transaction with these data to the blockchain nodes A smart contract on the blockchain that records the ciphertext after the signature verification with the Enclave Identity public key All TEEs in the network obtain the ciphertext recorded in the blockchain and decrypt it in Enclave to update the state Key Rotation Phase This phase rotates the group encryption keys shared through all TEEs. The workflow are follows: TEE's operator client sends a request to TEE for a key rotation Generate a new key internally or get a key externally, depending on the request Calculate TreeKEM's group state update using the new key To share the new state of TreeKEM to other TEEs, encrypt it using the public keys of the TEE members and broadcast it to the blockchain Each TEE decrypts the fetched ciphertext with its own private key, updates the group state of TreeKEM, and obtains a common group seed value for each.","title":"Workflow"},{"location":"Concepts/workflow/#registration-phase","text":"This is the phase where the public key is registered in the blockchain after verifying that TEE is executing a legitimate state transition program. On-chain validation of REPORT obtained by Remote Attestation and registration of the Enclave Identity public key included in it to the on-chain. REPORT verification includes REPORTS signature verification and MRENCLAVE match verification. The registration phase is the phase that takes place when a specific state transition logic is determined and a new Anonify network is generated, when a TEE joins an existing Anonify network, or when the REPORT timestamp expires. The workflow from the time TEE generates an Enclave to joining a specific group on Anonify is followings: Generate a closed Identity key pair for Enclave at the time of Enclave generation. Perform Remote Attestation. Include the Identity public key and Nonce in QUOTE, send it to the Attestation Service and receive the response of REPORT with a signature. Generate a handshake to share a group key Generate a transaction containing REPORT and handshake and broadcast it to the blockchain Through a series of REPORT verification on the blockchain, the registration of TEE is completed by recording the Identity public key on the blockchain. In the verification of the REPORT, if a new Anonify network is created, the MRENCLAVE is recorded in the blockchain. On the other hand, in case of joining the existing Anonify network, check whether the MRENCLAVE already recorded in the blockchain matches the MRENCLAVE presented.","title":"Registration Phase"},{"location":"Concepts/workflow/#state-transition-phase","text":"This is the phase where transactions are broadcast on the blockchain network to share the results of the cryptographic state transitions. A workflow where an external entity with credentials sends a transaction on Anonify, which is shared by the blockchain and reflected in the state of other TEEs is as follows: An external entity sends the authentication information and state transition inputs required for access to the TEE The authentication information is validated in Enclave, and the data is input to a defined state transition function and calculated TEE encrypts the result, calculates the lock parameters, signs it with the Enclave Identity private key, and broadcasts the transaction with these data to the blockchain nodes A smart contract on the blockchain that records the ciphertext after the signature verification with the Enclave Identity public key All TEEs in the network obtain the ciphertext recorded in the blockchain and decrypt it in Enclave to update the state","title":"State transition phase"},{"location":"Concepts/workflow/#key-rotation-phase","text":"This phase rotates the group encryption keys shared through all TEEs. The workflow are follows: TEE's operator client sends a request to TEE for a key rotation Generate a new key internally or get a key externally, depending on the request Calculate TreeKEM's group state update using the new key To share the new state of TreeKEM to other TEEs, encrypt it using the public keys of the TEE members and broadcast it to the blockchain Each TEE decrypts the fetched ciphertext with its own private key, updates the group state of TreeKEM, and obtains a common group seed value for each.","title":"Key Rotation Phase"},{"location":"Getting_Started/join/","text":"Deploy smart contract We'll deploy smart contract by deploy command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify deploy 6d68b0a618ab5a08be3600957f768c15c9b04baa Successfully deploying, we'll get an address. You can set the address to environment variable CONTRACT_ADDR . $ export CONTRACT_ADDR=6d68b0a618ab5a08be3600957f768c15c9b04baa After setting CONTRACT_ADDR , set_contract_addr set the contract address to Anonify. $ ANONIFY_URL=http://172.28.1.2:8080 ./target/debug/anonify-cli anonify set_contract_addr To check the state transition on Anonify network, we run start_polling command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify start_polling $ ANONIFY_URL=http://172.28.1.2:8080 ./target/debug/anonify-cli anonify start_polling Join Anonify network. Run register command to join Anonify network. This command submmits REPORT which is required for Atestted Computing and add handshake to share group key. $ ANONIFY_URL=http://172.28.1.2:8080 ./target/debug/anonify-cli anonify register Congratulations! You have already joined Anonify network. You can implement self-defined functions, refer to folloing section, and also progress to the tutorials of ERC20 functions .","title":"Join the Network"},{"location":"Getting_Started/join/#deploy-smart-contract","text":"We'll deploy smart contract by deploy command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify deploy 6d68b0a618ab5a08be3600957f768c15c9b04baa Successfully deploying, we'll get an address. You can set the address to environment variable CONTRACT_ADDR . $ export CONTRACT_ADDR=6d68b0a618ab5a08be3600957f768c15c9b04baa After setting CONTRACT_ADDR , set_contract_addr set the contract address to Anonify. $ ANONIFY_URL=http://172.28.1.2:8080 ./target/debug/anonify-cli anonify set_contract_addr To check the state transition on Anonify network, we run start_polling command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify start_polling $ ANONIFY_URL=http://172.28.1.2:8080 ./target/debug/anonify-cli anonify start_polling","title":"Deploy smart contract"},{"location":"Getting_Started/join/#join-anonify-network","text":"Run register command to join Anonify network. This command submmits REPORT which is required for Atestted Computing and add handshake to share group key. $ ANONIFY_URL=http://172.28.1.2:8080 ./target/debug/anonify-cli anonify register Congratulations! You have already joined Anonify network. You can implement self-defined functions, refer to folloing section, and also progress to the tutorials of ERC20 functions .","title":"Join Anonify network."},{"location":"Getting_Started/self_defined_functions/","text":"You can implement self defined logic on Anonify. Implement enclave memory You can use impl_memory macro to implement enclave memory. For example, ERC20 tutorials implement 4 memories like followings. impl_memory! { (0, \"Balance\", U64), (1, \"Approved\", Approved), (2, \"TotalSupply\", U64), (3, \"Owner\", UserAddress) } You specify the 3 arguments, first is the ID on enclave, second is the name of the memory and third is a type. \u72ec\u81ea\u95a2\u6570\u306e\u5b9a\u7fa9 You can implement self-defined functions by impl_runtime macro. The following is an exmple of implementation of transfer function using in ERC20 tutorials . impl_runtime!{ #[fn_id=1] pub fn transfer( self, sender: UserAddress, recipient: UserAddress, amount: U64 ) { let sender_balance = self.get_map::<U64>(sender, \"Balance\")?; let recipient_balance = self.get_map::<U64>(recipient, \"Balance\")?; ensure!(sender_balance > amount, \"transfer amount exceeds balance.\"); let sender_update = update!(sender, \"Balance\", sender_balance - amount); let recipient_update = update!(recipient, \"Balance\", recipient_balance + amount); insert![sender_update, recipient_update] } } update and insert macro enable us to run state transition.","title":"Implement Self-defined logic"},{"location":"Getting_Started/self_defined_functions/#implement-enclave-memory","text":"You can use impl_memory macro to implement enclave memory. For example, ERC20 tutorials implement 4 memories like followings. impl_memory! { (0, \"Balance\", U64), (1, \"Approved\", Approved), (2, \"TotalSupply\", U64), (3, \"Owner\", UserAddress) } You specify the 3 arguments, first is the ID on enclave, second is the name of the memory and third is a type.","title":"Implement enclave memory"},{"location":"Getting_Started/self_defined_functions/#_1","text":"You can implement self-defined functions by impl_runtime macro. The following is an exmple of implementation of transfer function using in ERC20 tutorials . impl_runtime!{ #[fn_id=1] pub fn transfer( self, sender: UserAddress, recipient: UserAddress, amount: U64 ) { let sender_balance = self.get_map::<U64>(sender, \"Balance\")?; let recipient_balance = self.get_map::<U64>(recipient, \"Balance\")?; ensure!(sender_balance > amount, \"transfer amount exceeds balance.\"); let sender_update = update!(sender, \"Balance\", sender_balance - amount); let recipient_update = update!(recipient, \"Balance\", recipient_balance + amount); insert![sender_update, recipient_update] } } update and insert macro enable us to run state transition.","title":"\u72ec\u81ea\u95a2\u6570\u306e\u5b9a\u7fa9"},{"location":"Getting_Started/setup/","text":"You can set up Anonify by following steps. Environments Hardware environment supports Intel SGX like Azure Confidential Computing Aleady installed cargo Set up We fetch docker image and Anonify repository. $ docker pull osuketh/anonify $ git clone git@github.com:LayerXcom/anonify.git $ cd anonify Anonify don't depend a specific blockchain platform. To store the state data, we connect Ethereum network as an example, so build smart contract. $ solc -o build --bin --abi --optimize --overwrite contracts/Anonify.sol Run server Using docker-compose , we run servers to connect to Anonify network. $ docker-compose -f docker/docker-compose-anonify.yml up -d Build CLI We build CLI to use Anonify commands. $ ./scripts/build-cli.sh","title":"Set up"},{"location":"Getting_Started/setup/#environments","text":"Hardware environment supports Intel SGX like Azure Confidential Computing Aleady installed cargo","title":"Environments"},{"location":"Getting_Started/setup/#set-up","text":"We fetch docker image and Anonify repository. $ docker pull osuketh/anonify $ git clone git@github.com:LayerXcom/anonify.git $ cd anonify Anonify don't depend a specific blockchain platform. To store the state data, we connect Ethereum network as an example, so build smart contract. $ solc -o build --bin --abi --optimize --overwrite contracts/Anonify.sol","title":"Set up"},{"location":"Getting_Started/setup/#run-server","text":"Using docker-compose , we run servers to connect to Anonify network. $ docker-compose -f docker/docker-compose-anonify.yml up -d","title":"Run server"},{"location":"Getting_Started/setup/#build-cli","text":"We build CLI to use Anonify commands. $ ./scripts/build-cli.sh","title":"Build CLI"},{"location":"Tutorials/ERC20/approve/","text":"This is section is about approve and transfer_from . Initial State Run init_state to initialize. ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify init_state -t 100 The command wallet list tells us the accounts registerd in wallet, following are the accounts of Alice, Bob and Charlie. If you haven't created the accounts yet, see the procuedure in mint and burn . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli wallet list Alice: JeMocNNkNqABAEqBEurffNHIr0Y= Bob: SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Charlie: On1lVfkMUGm6+lT3OetO8A2HR4M= Each balance are followings. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 approve We approve Bob 30 coins from Alice. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify approve -a 30 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Transaction Receipt: \"2cdda1f698c359e8eef6d94793c2713049eb8b3a2053fe2d744ad187253cf6ec\" Let's check the approved ammount to Bob by allowance command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify allowance -i 0 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Current State: 30 transfer_from Using transfer_from command, We send 10 coins from Bob to Charlie. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify transfer_from -a 10 -i 1 -f JeMocNNkNqABAEqBEurffNHIr0Y= -t On1lVfkMUGm6+lT3OetO8A2HR4M= Transaction Receipt: \"2a3732f73ed4ae0ca59ec758097f882d49348bbfd61a6cb156739a211fe807b0\" The State after executing transfer_from We check the final balances of Alice, Bob and Charlie. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 90 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 10 Charlie got 10 coins from Alice. And also, checking the approved balance of Bob. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify allowance -i 0 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Current State: 20 Executing transfer_from , the approved balance of Bob has decreased to 20 from 30 .","title":"approve/transfer_from"},{"location":"Tutorials/ERC20/approve/#initial-state","text":"Run init_state to initialize. ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify init_state -t 100 The command wallet list tells us the accounts registerd in wallet, following are the accounts of Alice, Bob and Charlie. If you haven't created the accounts yet, see the procuedure in mint and burn . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli wallet list Alice: JeMocNNkNqABAEqBEurffNHIr0Y= Bob: SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Charlie: On1lVfkMUGm6+lT3OetO8A2HR4M= Each balance are followings. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0","title":"Initial State"},{"location":"Tutorials/ERC20/approve/#approve","text":"We approve Bob 30 coins from Alice. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify approve -a 30 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Transaction Receipt: \"2cdda1f698c359e8eef6d94793c2713049eb8b3a2053fe2d744ad187253cf6ec\" Let's check the approved ammount to Bob by allowance command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify allowance -i 0 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Current State: 30","title":"approve"},{"location":"Tutorials/ERC20/approve/#transfer_from","text":"Using transfer_from command, We send 10 coins from Bob to Charlie. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify transfer_from -a 10 -i 1 -f JeMocNNkNqABAEqBEurffNHIr0Y= -t On1lVfkMUGm6+lT3OetO8A2HR4M= Transaction Receipt: \"2a3732f73ed4ae0ca59ec758097f882d49348bbfd61a6cb156739a211fe807b0\"","title":"transfer_from"},{"location":"Tutorials/ERC20/approve/#the-state-after-executing-transfer_from","text":"We check the final balances of Alice, Bob and Charlie. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 90 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 10 Charlie got 10 coins from Alice. And also, checking the approved balance of Bob. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify allowance -i 0 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Current State: 20 Executing transfer_from , the approved balance of Bob has decreased to 20 from 30 .","title":"The State after executing transfer_from"},{"location":"Tutorials/ERC20/mint_burn/","text":"This is section is about mint and burn . Initial State We create 3 accounts by using wallet init and wallet create commands, and also you must set wallet password and account name . $ ./target/debug/anonify-cli wallet init $ ./target/debug/anonify-cli wallet add-account $ ./target/debug/anonify-cli wallet add-account The command wallet list tells us the accounts registerd in wallet, following are the accounts of Alice, Bob and Charlie. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli wallet list Alice: JeMocNNkNqABAEqBEurffNHIr0Y= Bob: SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Charlie: On1lVfkMUGm6+lT3OetO8A2HR4M= Run init_state to initialize. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify init_state -t 100 Each balance are followings. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 mint Let's do minting 50 to Bob, mint command can be executed by only Alice who have executed init_state command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify mint -a 50 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Transaction Receipt: \"c05dc918cde8caa83e4233bff236285efc7197f554a844e590619d1c24d41b8d\" The State after executing mint We check the balances of Alice, Bob and Charlie after executing mint . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 50 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 Bob has got 50 coins by mint . burn We'll do burning 30 coins from Alice. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify burn -i 0 -a 30 Transaction Receipt: \"917576ddb5bdd68f01d2bb98f3ae4dcafec28c385bdb1033ed9b2b51529c4c22\" The State after executing burn We check the balances of Alice, Bob and Charlie after executing burn . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 70 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 50 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 We could see the Alice's balance is 70 , decreased from 100 by 30 coins. burn by not owner burn command can be executed by the non-owner account. Let's burn 10 coins from Bob. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify burn -i 1 -a 10 Transaction Receipt: \"59d139d1ea29ddd008ecb7947b55677d9013b24f5b7de3ea2b70badfcfe3c848\" The State after executing burn by not owner We check the balances of Alice, Bob and Charlie after executing burn by Bob. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 70 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 40 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 We could see the Bob's balance is 40 , decreased from 50 by 10 coins. And also any other account's balance have not changed.","title":"mint/burn"},{"location":"Tutorials/ERC20/mint_burn/#initial-state","text":"We create 3 accounts by using wallet init and wallet create commands, and also you must set wallet password and account name . $ ./target/debug/anonify-cli wallet init $ ./target/debug/anonify-cli wallet add-account $ ./target/debug/anonify-cli wallet add-account The command wallet list tells us the accounts registerd in wallet, following are the accounts of Alice, Bob and Charlie. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli wallet list Alice: JeMocNNkNqABAEqBEurffNHIr0Y= Bob: SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Charlie: On1lVfkMUGm6+lT3OetO8A2HR4M= Run init_state to initialize. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify init_state -t 100 Each balance are followings. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0","title":"Initial State"},{"location":"Tutorials/ERC20/mint_burn/#mint","text":"Let's do minting 50 to Bob, mint command can be executed by only Alice who have executed init_state command. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify mint -a 50 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Transaction Receipt: \"c05dc918cde8caa83e4233bff236285efc7197f554a844e590619d1c24d41b8d\"","title":"mint"},{"location":"Tutorials/ERC20/mint_burn/#the-state-after-executing-mint","text":"We check the balances of Alice, Bob and Charlie after executing mint . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 50 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 Bob has got 50 coins by mint .","title":"The State after executing mint"},{"location":"Tutorials/ERC20/mint_burn/#burn","text":"We'll do burning 30 coins from Alice. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify burn -i 0 -a 30 Transaction Receipt: \"917576ddb5bdd68f01d2bb98f3ae4dcafec28c385bdb1033ed9b2b51529c4c22\"","title":"burn"},{"location":"Tutorials/ERC20/mint_burn/#the-state-after-executing-burn","text":"We check the balances of Alice, Bob and Charlie after executing burn . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 70 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 50 $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 We could see the Alice's balance is 70 , decreased from 100 by 30 coins.","title":"The State after executing burn"},{"location":"Tutorials/ERC20/mint_burn/#burn-by-not-owner","text":"burn command can be executed by the non-owner account. Let's burn 10 coins from Bob. $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify burn -i 1 -a 10 Transaction Receipt: \"59d139d1ea29ddd008ecb7947b55677d9013b24f5b7de3ea2b70badfcfe3c848\"","title":"burn by not owner"},{"location":"Tutorials/ERC20/mint_burn/#the-state-after-executing-burn-by-not-owner","text":"We check the balances of Alice, Bob and Charlie after executing burn by Bob. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 70 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 40 # Charlie's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 2 Current State: 0 We could see the Bob's balance is 40 , decreased from 50 by 10 coins. And also any other account's balance have not changed.","title":"The State after executing burn by not owner"},{"location":"Tutorials/ERC20/transfer/","text":"This is section is about transfer . Initial State Run init_state to initialize. ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify init_state -t 100 The command wallet list tells us the accounts registerd in wallet, following are the accounts of Alice and Bob. If you haven't created the accounts yet, see the procuedure in mint and burn . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli wallet list Alice: JeMocNNkNqABAEqBEurffNHIr0Y= Bob: SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Each balance are followings. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0 transfer We transfer 20 coins from Alice to Bob. \uff04 ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify transfer -a 20 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Transaction Receipt: \"0d89b58846a0db41976c6f95c62c5bfb63a5b2d4e29a560d652b913889edfde8\" The State after executing transfer We check the balances after transfering. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 80 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 20 Finally, we could transfer 20 coins from Alice to Bob.","title":"transfer"},{"location":"Tutorials/ERC20/transfer/#initial-state","text":"Run init_state to initialize. ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify init_state -t 100 The command wallet list tells us the accounts registerd in wallet, following are the accounts of Alice and Bob. If you haven't created the accounts yet, see the procuedure in mint and burn . $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli wallet list Alice: JeMocNNkNqABAEqBEurffNHIr0Y= Bob: SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Each balance are followings. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 100 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 0","title":"Initial State"},{"location":"Tutorials/ERC20/transfer/#transfer","text":"We transfer 20 coins from Alice to Bob. \uff04 ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify transfer -a 20 -t SyQwvGjGQmA4OG1ZV2zMNn4GXpA= Transaction Receipt: \"0d89b58846a0db41976c6f95c62c5bfb63a5b2d4e29a560d652b913889edfde8\"","title":"transfer"},{"location":"Tutorials/ERC20/transfer/#the-state-after-executing-transfer","text":"We check the balances after transfering. # Alice's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 0 Current State: 80 # Bob's Balance $ ANONIFY_URL=http://172.28.1.1:8080 ./target/debug/anonify-cli anonify balance_of -i 1 Current State: 20 Finally, we could transfer 20 coins from Alice to Bob.","title":"The State after executing transfer"}]}